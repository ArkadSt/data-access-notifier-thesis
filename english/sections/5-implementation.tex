\section{Implementation}

\subsection{Description}

The main objective of this thesis has been to develop a solution that would notify users of data access events logged in the \textit{Andmejälgija} (Data Tracker) system. The resulting solution provides near real-time notifications when government institutions or other authorized entities access an eID holder's personal data.

\subsection{Discussion of implementation choice}
There are several possible approaches for developing such a solution. In this section different implementation options will be discussed, as well as their advantages and disadvantages.

\subsubsection{X-Road service}
\textit{Andmejälgija} specifications require entities responsible for the state databases to implement an X-Road interface themselves, as described in \ref{protocol_desc}, so one option would be to create an X-Road service that would query \textit{Andmejälgija} data over X-Road directly from those entities. The main advantage of this approach would be the freedom in how to notify users of changes to the access logs. As a server-based solution, the service could support various communication channels for delivering notifications to users, including instant messenger bots or e-mail notifications, for example. However, the list of requirements to operate such a service is daunting. 

\begin{itemize}
    \item {In order to join X-Road, a legal entity is needed.}
    \item {Permission has to be requested from every X-Road service you want to query data from. Specifically, considering that each information system is responsible for implementing the \textit{Andmejälgija} protocol themselves, the permission would be required from each entity responsible for the information systems from which the access logs would be requested.}
    \item {As part of X-Road network, one needs to operate a Security Server. For testing, it can be self-hosted on any hardware, but for production, a Hardware Security Module (HSM) is needed, in order to be compliant with eIDAS requirements. Obtaining or renting such hardware involves substantial financial investment. For example, a Thales Luna PCIe HSM A700 suitable for eIDAS qualified digital signing costs €8,990 (€10,877.90 incl. VAT) \cite{thales-luna-hsm-pricing}. Alternatively, renting a production ready Security server from Telia costs 210€ per month \cite{telia-xroad-server}}
    \item {Finally, considering that this approach would include creating a service that would store and transmit user's data, it would be required to follow strict regulatory requirements including the General Data Protection Regulation (GDPR). Staying compliant requires a continuous effort, and in case of failure to do so, there are harsh fines.}
\end{itemize}

Satisfying this criteria is difficult and expensive. Additionally, even with successful implementation, people would have to consent and entrust me with their data in order to be able to use the solution, which is not in the spirit of creating a solution for monitoring personal data access, as another data controller would be introduced.

\subsubsection{Standalone approach}
This approach uses the \textit{\href{https://www.eesti.ee}{eesti.ee}} session for accessing \textit{Andmejälgija} data. Once the user is logged in to the \textit{\href{https://www.eesti.ee}{eesti.ee}} state portal, certain internal API endpoints become available. Namely the \texttt{GET} endpoint \texttt{https://www.\href{https://www.eesti.ee}{eesti.ee}/\\andmejalgija/api/v1/usages} can be used to query \textit{Andmejälgija} data. The endpoint requires a parameter \texttt{dataSystemCodes} with which specific databases can be specified. For example, the GET request \texttt{/usages?dataSystemCodes=digiregistratuur\&\\dataSystemCodes=rahvastikuregister} would request access logs from \textit{Digiregistratuur} and \textit{Rahvastikuregister}.

The main advantage of this approach is the absence of all disadvantages of the X-Road approach: there are no legal requirements and the solution could be an open-source project, available for anybody to compile and use. There arises a problem, however. What about the notification part? Are users expected to set everything up on their hardware, including relevant communication channels? That would narrow down the project's user base to technical people knowing how to self-host, and having a server.

Consequently, creating a mobile application was determined to be the most optimal approach. A mobile application would keep the \textit{\href{https://www.eesti.ee}{eesti.ee}} session alive and poll the \textit{Andmejälgija} API. This approach combines ease of setup and use while keeping the solution standalone, without requiring a central server.

\subsection{Development}

First, the feasibility and reliability of the standalone approach had to be determined, especially as the approach would include a reverse-engineering of the user-facing service. The main challenge was to keep the session alive for as long as possible.

The \textit{\href{https://www.eesti.ee}{eesti.ee}} session is established using one of the strong authentication methods via the \textit{TARA} (Trusted Authentication and Authorization) service. Once the user is authenticated using ID-card, Mobile-ID, Smart-ID, or eID solution of another EU country, a JSON Web Token (JWT) token is issued, valid for 30 minutes. The session management is then handled by \textit{GovSSO} (Government Single Sign-On), which maintains the master server-side session token and imposes certain limitations as discussed in \ref{session-limitations}.

Once the user is authenticated, certain internal API endpoints become available, including those for refreshing the JWT token and getting \textit{Andmejälgija} access logs. The JWT refresh endpoint returns \texttt{Set-Cookie} headers that include an updated \texttt{JWTTOKEN} on success, with an updated expiration date (30 minutes from the moment of extension).

To test whether the session could be kept alive indefinitely, the Tab Reloader extension for Firefox by James Fray \cite{tab-reloader-addon} was used. Using this browser extension, the browser was configured to automatically reload the tab with the JWT token refresh endpoint. After the 8-hour experiment, the approach was deemed successful.

The next step was the development of the \textbf{Data Access Notifier} Android application. The reason why Android was chosen over iOS is that Android development is significantly more accessible for developers who do not own an Apple computer. Unlike iOS, Android development can be performed on nearly any modern computer with reasonably common operating system installed, including Linux.

The application was developed using the Kotlin programming language due to it being the new standard for developing Android applications \cite{kotlin-first}, as well as its more expressive syntax and promise of faster development speed.

The application is compatible with all Android versions starting from Android 8.1, meaning that it works on approximately 96.4\% of Android devices according to the Android Studio API version distribution chart shown in Figure~\ref{fig:android-api-distribution}.

\begin{figure}[H]
\centering
\includegraphics[width=450px]{english/figures/Screenshot from 2025-08-11 22-58-16.png}
\caption{Android Studio API Level Distribution for Android 8.1+ compatibility}
\label{fig:android-api-distribution}
\end{figure}

Currently, the application support is limited to Android 8.1 and higher. While support for iOS and other platforms is not planned due to limited development time and resources, anybody who deems this solution useful is encouraged to port it to platforms other than Android.

\subsubsection{Licensing}
The \textbf{Data Access Notifier} application is released as open-source software under the MIT License. This simple and permissive license allows users to freely use, modify, and distribute the software for both commercial and non-commercial purposes. 

The choice of MIT License aligns with the project's goal of providing a transparent and accessible solution for personal data monitoring, enabling the broader community to contribute to and benefit from the development efforts without strict licensing barriers.

\subsubsection{Authentication}
To gain access to \textit{\href{https://www.eesti.ee}{eesti.ee}} internal APIs, the user needs to be authenticated via the State Authentication Service (\textit{TARA}). The initial plan was to reverse engineer the authentication flow and authenticate the user by sending raw HTTP requests and handling responses. This approach, however, would be fragile and require substantial engineering effort to develop and maintain due to the flow being fairly complex and prone to unannounced changes to \textit{TARA}.

Instead, it was decided to use Android WebView for authentication as a more reliable and convenient approach for both the user and the developer. By leveraging WebView, the \textbf{Data Access Notifier} application can present the official \textit{TARA} login page directly to the user, allowing them to authenticate using their preferred method (ID-card, Mobile-ID, Smart-ID, or eID of another EU country). This approach significantly reduces the risk of breaking changes due to updates on the \textit{\href{https://www.eesti.ee}{eesti.ee}} or \textit{TARA} platforms. Once the user is authenticated, the application can access the necessary session cookies and JWT token to interact with the internal APIs.

\subsubsection{Interacting with \textit{\href{https://www.eesti.ee}{eesti.ee}} internal APIs}
For interacting with \textit{\href{https://www.eesti.ee}{eesti.ee}} internal APIs, the OkHttp library by Square, Inc.\cite{okhttp-library} was used. The following API endpoints were utilized:

\begin{itemize}
    \item \textbf{GET} \texttt{https://www.\href{https://www.eesti.ee}{eesti.ee}/timur/jwt/extend-jwt-session}
    
    An endpoint for extending JWT session.
    
    \item \textbf{GET} \texttt{https://www.\href{https://www.eesti.ee}{eesti.ee}/andmejalgija/api/v1/usages}
    
    An endpoint for querying Data Tracker access logs.
    
    Query parameters:
    \begin{itemize}
        \item \texttt{dataSystemCodes}: The name of the information system the access logs are queried from.
    \end{itemize}
    
    \samepage
    Response body format (JSON):
    \begin{listing}[H]
    \begin{minted}{json}
{
  "findUsageResponses": [
    {
      "logTime": "2025-08-03T22:40:47",
      "receiver": "Tervise ja Heaolu Infosüsteemide Keskus",
      "infoSystemCode": "rahvastikuregister",
      "action": "ISIKU NIME VÄLJASTAMINE ISIKUKOODI PÕHJAL"
    },
    // more objects to follow
  ]
}
    \end{minted}
    \caption{API response format for Andmejälgija usage data}
    \label{lst:andmejalgija-response}
    \end{listing}
    
    Response fields:
    \begin{itemize}
        \item \texttt{logTime}: Timestamp of the data access event in ISO 8601 format
        \item \texttt{receiver}: Entity that accessed the data
        \item \texttt{infoSystemCode}: The information system where the data has been accessed.
        \item \texttt{action}: Description of the action performed (in Estonian)
    \end{itemize}
\end{itemize}

Both endpoints require a valid JWT token to succeed. WebView's \texttt{CookieManager} serves as a single source of truth in this application, where all cookies are loaded from for making requests and written to upon receiving responses.

\subsubsection{Keeping the session alive}
The API requests are authenticated using a JWT token cookie, the lifetime of which is 30 minutes. This means that the \textbf{Data Access Notifier} application must either run a continuous foreground service or be awakened periodically to request an updated JWT token and send requests to \textit{Andmejälgija}.

On Android, there are several ways to accomplish this, although it is worth mentioning that Android is very restrictive regarding background tasks and battery usage. Several approaches were tried and the experience with them in the context of developing this application will be described.

\subsubsection{WorkManager approach}
According to the Android documentation, WorkManager is the recommended solution for persistent work \cite{android-persistent-work}. Work is persistent when it remains scheduled through application restarts and system reboots. This seemed to describe the use case very well, so this was the first approach that was tried.

Work is defined in WorkManager using a WorkRequest. There are several WorkRequest types available, including \texttt{PeriodicWorkRequest} and \texttt{OneTimeWorkRequest}.

Using \texttt{PeriodicWorkRequest}, it is possible to schedule periodic tasks. The important limitation here is that it is not possible to schedule a task to execute more frequently than every 15 minutes. While this may sound appropriate for the use case of having to renew the session at least every 30 minutes, in practice, the situation is different.

During development, a critical difference between session handling in web browsers versus HTTP client libraries was discovered. While the browser-based testing with Tab Reloader successfully maintained the session by refreshing the JWT token every 15 minutes, the same approach using OkHttp in the Android application failed to keep the session alive.

The exact cause of this discrepancy remains unclear. It appears that the \textit{\href{https://www.eesti.ee}{eesti.ee}} session management system expects more frequent interaction or handles cookie management differently when requests originate from HTTP client libraries compared to full web browsers. Indeed, with shorter intervals of 5 minutes, the session remains alive. This behavioral difference rendered the \texttt{PeriodicWorkRequest} approach with 15-minute intervals unsuitable for maintaining persistent sessions in the application context.

While \texttt{OneTimeWorkRequest} is designed for one-time tasks, it is possible to chain them by having each one-time work create another one-time work at the end of its lifespan. This approach allows setting custom intervals shorter than 15 minutes, circumventing the limitation imposed by \texttt{PeriodicWorkRequest}.

While \texttt{OneTimeWorkRequest} may appear to be a suitable solution, WorkManager itself proved to be rather unreliable for the use case after testing. The limitation of WorkManager is that tasks scheduled by it are managed by the system and may be deferred if deemed necessary by the Android system. For example, tasks may not execute if the phone has low battery level, or even in other scenarios depending on the aggressiveness of the Android variant regarding the restrictions imposed on application behavior.

\subsubsection{Foreground service approach}
A foreground service is one of the most reliable types of tasks an application can schedule. In contrast to background services, foreground services are considered to be of higher priority by the system and thus are not candidates for termination when the system is low on memory or the phone has low battery level.

However, an important limitation has been introduced in recent Android versions. More specifically, starting from Android 15, the system places restrictions on how long certain foreground services are allowed to run while the application is in the background. Currently, this restriction only applies to \texttt{dataSync} and \texttt{mediaProcessing} foreground service types. The foreground services of those types are allowed to run for a total of 6 hours in a 24-hour period \cite{android-15-datasync-timeout}.

The most appropriate foreground service type for the use case is \texttt{dataSync}, meaning that it falls under the 6-hour per day restriction. While it should be possible to choose an arbitrary foreground service type regardless of the actual task type, doing so is not the cleanest approach, especially considering the existence of better alternatives. Furthermore, doing so may also impact the application's acceptance into the Google Play Store.

\subsubsection{Hybrid AlarmManager approach}
\label{alarmmanager-approach}
After evaluating the limitations of WorkManager and the restrictions on foreground services, a hybrid approach combining AlarmManager with a \texttt{dataSync} foreground service was ultimately adopted. AlarmManager is a system service that allows scheduling operations to be executed at specific times, even if the application is not running. By using AlarmManager to trigger the application at regular intervals (e.g., every 5 minutes), it is ensured that the session renewal and data polling tasks are reliably executed.

When the alarm fires, the application starts a short-lived \texttt{dataSync} foreground service to perform the necessary network operations: refreshing the JWT token and querying the \textit{Andmejälgija} API. This approach leverages the reliability of foreground services for critical tasks while minimizing battery usage by only running the service when needed. AlarmManager itself is not subject to aggressive background restrictions and can wake the application even in Doze mode, making it suitable for periodic tasks.

This solution proved to be robust and reliable across different Android versions and device manufacturers. Both AlarmManager and foreground services are extremely reliable even under low battery conditions, ensuring that the session remains alive and notifications are delivered promptly to the user.

\subsubsection{Session limitations}
\label{session-limitations}
During the development and testing process, an important server-side limitation that affects the overall feasibility of the session-based approach was discovered. Despite the successful implementation of session renewal mechanisms, the \textit{GovSSO} session management system imposes a hard limit of 12 hours on session duration. After this period, the session expires permanently and cannot be renewed.

The problem was discovered when it became apparent that JWT extension fails regularly with response code \texttt{500} (Internal Server Error) from the server and no further information. Following a number of retries, the server would send code \texttt{400} (Bad Request). At some point a pattern was identified, and it was discovered that the session extension starts failing after exactly 12 hours. The \textit{GovSSO} GitHub repository \cite{govsso-session} was investigated and the answer was found in the configuration file.

In the file \texttt{/src/main/resources/application.yml}, the following configuration parameter is defined \cite{govsso-session-config}:

\begin{listing}[H]
\begin{minted}{yaml}
session-max-duration-hours: 12
\end{minted}
\caption{GovSSO session configuration parameter \cite{govsso-session-config}}
\label{lst:govsso-config}
\end{listing}

The function responsible for checking the \texttt{notBefore} date of the JWT token is shown below \cite{govsso-session-hydra}:

\begin{listing}[H]
\begin{minted}{java}
private boolean isNbfValid(JWT idToken) throws ParseException {
    Date idTokenDate = idToken.getJWTClaimsSet().getNotBeforeTime();
    Date currentDate = new Date();
    long diffInMillis = Math.abs(currentDate.getTime() -
                                        idTokenDate.getTime());
    long diffInSeconds = TimeUnit.SECONDS.convert(diffInMillis, 
                                        TimeUnit.MILLISECONDS);
    long maxDurationInSeconds = TimeUnit.SECONDS.convert(
        ssoConfigurationProperties.getSessionMaxDurationHours(), 
        TimeUnit.HOURS);

    return diffInSeconds <= maxDurationInSeconds;
}
\end{minted}
\caption{GovSSO JWT token validation function}
\label{lst:govsso-jwt-validation}
\end{listing}

Initially, it was hypothesized that this limitation was related to the JWT token issued to the client, with the server rejecting it once it reaches the age of 12 hours. This would have been an easy fix, as there is another way to extend the session that would issue a ``fresh" JWT token each time. As can be derived from the name \textit{GovSSO}, this authentication service supports single-sign-on, meaning that if you are signed into one state e-service, you can log into another by clicking a ``Continue session" button, as demonstrated in Figure~\ref{fig:eesti-ee-continue-session}. The same can be achieved for the same state portal where the system was initiated, if you go to the right URL. Automating this type of flow is relatively simple to implement.

\begin{figure}[H]
\centering
\includegraphics[width=450px]{english/figures/Screenshot from 2025-08-08 20-37-42.png}
\caption{GovSSO single sign-on interface with session continuation option \cite{eesti-ee-screenshot}}
\label{fig:eesti-ee-continue-session}
\end{figure}

However, after experimenting with this method, it was discovered that the 12-hour limitation applies to a different token than initially expected. The time validation is not performed on the client-side JWT token that the application receives, but rather on a server-side master JWT token that is created during the initial \textit{TARA} authentication process (ID-card, Mobile-ID, Smart-ID, etc.) and managed by \textit{GovSSO}.

When a user logs into additional services using the single-sign-on functionality, these secondary sessions are all linked to the same original server-side JWT token managed by \textit{GovSSO}. This architecture means that regardless of which session extension method is used, the 12-hour limit cannot be circumvented because all sessions share the same underlying authentication token that expires after 12 hours.

This limitation has significant implications for the notification system's reliability. Users who expect continuous monitoring must re-authenticate manually at least once every 12 hours to maintain the service functionality. However, this constraint is substantially mitigated by the API's design, which ensures that no data access events are permanently lost, though it does introduce periodic interruptions in real-time monitoring.

Specifically, the API returns comprehensive historical access logs, ensuring that once a user re-authenticates after a session expiry, they will receive all notifications for events that occurred during the period when they were logged out. This behavior is crucial for maintaining data completeness and ensuring that no critical access events are missed due to authentication gaps. The technical implementation of this log handling is detailed in \ref{log-handling}.

Additionally, in order to enhance user awareness of session expiry, the application implements a proactive notification mechanism, as shown in Figure~\ref{fig:session-expiry-notification}, informing the user that they have been logged out and prompting them to re-authenticate to continue monitoring.

\begin{figure}[H]
\centering
\includegraphics[width=250px]{english/figures/Screenshot_20250812_212624_Data Access Notifier.jpg}
\caption{Notification informing the user about session expiry.}
\label{fig:session-expiry-notification}
\end{figure}

\subsubsection{Handling logs and notification delivery}
\label{log-handling}
In this section the following aspects of access log handling will be tackled: their storage, deduplication and filtering.

First of all, user inquiries about themselves are also considered data access and therefore produce access logs. This includes \textit{Andmejälgija} data queries. However, making frequent queries to the \textit{Andmejälgija} API produces numerous logs. 

This makes it important to distinguish logs made by the user themselves from the logs made by third-parties. Thankfully, the \texttt{receiver} field contains the user's Estonian personal code in case the query is made by them. In fact, filtering by whether the receiver field contains user's personal code is exactly how the access log filtering is implemented on \textit{\href{https://www.eesti.ee}{eesti.ee}} itself when the user ticks the ``Exclude queries I have made/initiated" checkbox. Here is the \textit{\href{https://www.eesti.ee}{eesti.ee}} code extract that demonstrates this approach \cite{eesti-ee-portal}:

\begin{listing}[H]
\begin{minted}{javascript}
this.accountService.getUserInfo().subscribe((o) => {
    this.filteredData.data = this.filteredData.data.filter(
        (d) => !d.receiver.toUpperCase()
                   .includes(o.personalCode.replace(/^EE/, ""))
    );
})
\end{minted}
\caption{Estonian state portal JavaScript code for filtering self-access events}
\label{lst:eesti-ee-filtering}
\end{listing}

The same approach was used to implement access log filtering in the \textbf{Data Access Notifier} application. The user's personal code that is needed for filtering is extracted from the JWT token, along with the user's first name which is used to greet the user.

For deduplication of access logs, the \texttt{Set} data structure was utilized. Each access log entry is represented as a data class, and a \texttt{Set} of these entries is maintained to ensure that duplicate logs are not stored or processed multiple times. This approach leverages the fact that \texttt{Set}s in Kotlin do not allow duplicate elements.

To persist the access logs across application restarts and device reboots, Proto Data Store was used, which is Android's recommended solution for storing typed objects or lists in a transactional and type-safe manner. Proto Data Store uses Protocol Buffers \cite{protocol-buffers} for serialization, offering efficient storage and schema evolution capabilities.

Whenever new logs are fetched from the API, they are first filtered to exclude self-access events. The newly fetched logs are then merged with the existing logs stored in Proto Data Store, and the combined set is deduplicated using Kotlin's \texttt{Set} data structure. To determine which logs are new and should trigger notifications, the application computes the set difference between the combined deduplicated logs and the previously stored logs. Only the new items resulting from this difference are used to notify the user. This approach ensures that notifications are sent only for genuinely new access events, while avoiding redundant alerts for logs that have already been seen.

\subsection{Software distribution}

The \textbf{Data Access Notifier} application is distributed as an open-source project hosted on GitHub \cite{data-access-notifier}. Users can download the \texttt{APK} file directly from the GitHub Releases page \cite{data-access-notifier-releases}. To keep the application up to date, users can utilize third-party applications such as Obtainium \cite{obtainium}, which enables automatic updates for applications distributed outside of traditional application stores.

While the application is not currently available from application stores like Google Play Store, this possibility is not excluded in the future. Any updates regarding the application distribution would be posted on GitHub README.

\subsection{User guide}
After installation and opening for the first time, the \textbf{Data Access Notifier} application will prompt the user for necessary permissions, which are the ability to schedule alarms (for AlarmManager to work) as well as to post notifications.

Once the necessary permissions are given, the Log In screen appears. When the Log In button is pressed, an Android WebView is opened, redirecting the user to the \textit{TARA} Log In screen. There the user is free to choose their preferred state authentication option.

The setup process is now complete. As soon as authentication is successfully completed, the user will start receiving notifications whenever new data access logs are returned from the server. There is also a view inside of the application showing all data access logs saved. The setup process is illustrated in Figure~\ref{fig:app-usage}, with the relevant settings page for permitting the application to schedule alarms being opened automatically.

\begin{figure}[H]
\centering
\begin{minipage}{0.32\textwidth}
    \centering
    \includegraphics[width=\textwidth]{english/figures/Screenshot_20250812_212139_Settings.jpg}
\end{minipage}%
\hfill
\begin{minipage}{0.32\textwidth}
    \centering
    \includegraphics[width=\textwidth]{english/figures/Screenshot_20250812_212153_Permission controller.jpg}
\end{minipage}%
\hfill
\begin{minipage}{0.32\textwidth}
    \centering
    \includegraphics[width=\textwidth]{english/figures/Screenshot_20250812_212555_Data Access Notifier.jpg}
\end{minipage}
\begin{minipage}{0.32\textwidth}
    \centering
    \includegraphics[width=\textwidth]{english/figures/Screenshot_20250812_212238_Data Access Notifier.jpg}
\end{minipage}%
\hfill
\begin{minipage}{0.32\textwidth}
    \centering
    \includegraphics[width=\textwidth]{english/figures/Screenshot_20250812_212306_Data Access Notifier.jpg}
\end{minipage}%
\hfill
\begin{minipage}{0.32\textwidth}
    \centering
    \includegraphics[width=\textwidth]{english/figures/Screenshot_20250812_212336_Data Access Notifier.jpg}
\end{minipage}
\caption{Authentication to Data Access Notifier}
\label{fig:app-usage}
\end{figure} 

Once authenticated, users will start receiving real-time alerts when their data is accessed, as shown in Figure~\ref{fig:data-access-notification}.

\begin{figure}[H]
\centering
\includegraphics[width=250px]{english/figures/Screenshot_20250801_133754_Signal.jpg}
\caption{Data access notification}
\label{fig:data-access-notification}
\end{figure}

\subsection{Observations while using \textbf{Data Access Notifier}}
\label{observations}

While using the \textbf{Data Access Notifier} application over several weeks, several interesting observations were made about the behavior of the \textit{Andmejälgija} API and the reliability of real-time access logging.

One notable discovery was related to delayed log entries. Notifications were occasionally received for access events dated several months in the past - specifically, events from May 2025 would sometimes appear in August 2025. Initially, this was suspected to be a deduplication issue within the application, but after examining the stored notification history, it became clear that these were genuinely new log entries that had not been seen previously by the application.

This behavior suggests that there may be delays in the centralized logging infrastructure of \textit{Andmejälgija}, where some access events are not immediately recorded or made available through the API.

The application demonstrated substantial reliability in maintaining the authentication session during the 12-hour window. The hybrid AlarmManager approach (described in \ref{alarmmanager-approach}) successfully maintained connectivity even during extended periods of device inactivity or network fluctuations.

From a user experience perspective, the notifications provided valuable insights into data access patterns that would otherwise remain unnoticed. This transparency feature proved particularly useful for understanding which organizations access personal data and how frequently such access occurs.

\subsection{Limitations}
The most significant limitation of the \textbf{Data Access Notifier} application is the 12-hour session expiry imposed by the \textit{GovSSO} authentication system. As discussed in \ref{session-limitations}, this server-side restriction cannot be circumvented through known technical means, requiring users to manually re-authenticate.

While the application successfully preserves all access log data during authentication gaps - ensuring no events are permanently lost - the periodic interruptions in real-time monitoring represent a substantial usability constraint.

Additionally, the application's scope is currently limited to Android devices running version 8.1 and higher. While this covers approximately 96.4\% of the Android ecosystem, users of iOS or other mobile platforms cannot benefit from this solution without platform-specific implementations.

The reliance on reverse-engineered internal APIs also introduces inherent fragility. Changes to \textit{\href{https://www.eesti.ee}{eesti.ee}}'s internal API structure or authentication mechanisms could potentially break the application's functionality without notice, requiring an update to the application to fix the issue.

Additionally, the session-based approach requires the device to maintain active network connectivity and remain operational to perform periodic authentication renewals and API polling. Extended periods of device inactivity, airplane mode, or network unavailability will result in session expiry and temporary loss of monitoring capabilities.

The application also doesn't currently support the access logging implemented in \textit{E-File}.

Finally, the \textit{Andmejälgija} protocol itself is not regulated by the law yet, so information systems are not required to implement it, and even if they do, not all data access events are guaranteed to be timely distributed or logged at all.

\subsubsection{Tested devices}
The \textbf{Data Access Notifier} application has been tested on the following devices:
\begin{itemize}
    \item Xiaomi Poco X3 Pro running CrDroid without Google Services 
    \item Xiaomi Redmi 7A running Lineage OS without Google Services
    \item Samsung Galaxy S25 with stock OS (Google Services included)
\end{itemize}

\subsection{Battery usage}
\textbf{Data Access Notifier} application maintains relatively low power consumption despite its continuous background operation. The hybrid AlarmManager approach with short-lived foreground services appears to be efficient in terms of battery impact.

While the battery utilization hasn't been actively monitored, some screenshots have been taken on Samsung Galaxy S25 at different times during the active use period, as shown in Figure~\ref{fig:battery-usage}.

\begin{figure}[H]
\centering
\begin{minipage}{0.32\textwidth}
    \centering
    \includegraphics[width=\textwidth]{english/figures/IMG_20250809_225839_242.jpg}
\end{minipage}%
\hfill
\begin{minipage}{0.32\textwidth}
    \centering
    \includegraphics[width=\textwidth]{english/figures/IMG_20250809_225839_290.jpg}
\end{minipage}%
\hfill
\begin{minipage}{0.32\textwidth}
    \centering
    \includegraphics[width=\textwidth]{english/figures/IMG_20250809_225839_295.jpg}
\end{minipage}
\caption{Battery usage statistics for Data Access Notifier on Samsung Galaxy S25}
\label{fig:battery-usage}
\end{figure}

\subsection{Bug reports}

Users are encouraged to report any bugs, issues, or unexpected behavior through the GitHub Issues page of the project repository \cite{data-access-notifier}. When submitting bug reports, users should include:

\begin{itemize}
    \item Device model and Android version
    \item Detailed description of the issue
    \item Steps to reproduce the problem
    \item Any relevant error messages or screenshots
    \item Application version number
\end{itemize}

This feedback mechanism helps improve the application's stability and reliability across different Android devices and configurations.

\subsection{Contributions}
The \textbf{Data Access Notifier} project welcomes contributions from the community. Contributions are to be submitted as pull requests to the GitHub repository. Contributors can also contact the original author directly at \href{mailto:arkadistatsenko@gmail.com}{arkadistatsenko@gmail.com} for questions, suggestions, or collaboration opportunities.




